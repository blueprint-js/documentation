{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blueprint # A modern, powerful, experimental, and modular Discord bot framework Installation # You can install any version after 4.0.0 using the below command: 1 npm i blueprint-framework If you want to install a version below 4.0.0 , please install using the legacy repository: 1 npm i @dxz/blueprint Please note that any version below 4.0.0 will not recieve any security updates or bug fixes.","title":"Home"},{"location":"#blueprint","text":"A modern, powerful, experimental, and modular Discord bot framework","title":"Blueprint"},{"location":"#installation","text":"You can install any version after 4.0.0 using the below command: 1 npm i blueprint-framework If you want to install a version below 4.0.0 , please install using the legacy repository: 1 npm i @dxz/blueprint Please note that any version below 4.0.0 will not recieve any security updates or bug fixes.","title":"Installation"},{"location":"commands/","text":"Commands # Blueprint uses a Command class to manage the implementation of commands, for things such as the command's meta, a super() call with the meta of the command, such as the name, groups, aliases, and guards must be used. An example of creating a command can be seen below in the Creating Commands section. Note that this is a breaking change from the old pre-2.4.0 decorator method. Guards # Guards a way to add pre-checks to commands. They are simply functions that take the message context and a reference to the blueprint instance and return a GuardResult type. In order for a command using guards to execute, all guards must pass . 1 2 3 4 5 6 7 import { Guard , BaseConfig } from 'blueprint-framework' ; import { TextChannel } from 'discord.js-light' ; const isNsfw : Guard < BaseConfig > = ctx => { if (( ctx . channel as TextChannel ). nsfw ) return { passed : true }; else return { passed : false , message : \"The channel is not marked as NSFW\" }; }; Creating Commands # Commands are classes extending the abstract Command class, to set up a command you need to use the super() method to assign the command's meta information, then implement the abstract callback method with the functionality of the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export class PingCommand extends Command { constructor () { super ( 'ping' , { aliases : [ 'latency' , 'lag' ], groups : [ 'user' ], guards : [], }); } async callback ( ctx : CommandContext < BaseConfig > ) { const startTime = Date . now (); const msg = await ctx . message . channel . send ( 'loading...' ); msg . edit ( 'The current ping is `' + ( Date . now () - startTime ) + 'ms`' ); } } Handling Guard Failures # When any guard in a command returns false from it's passed property in a result, an optional fail callback is called that can be defined on the meta of a command within the super call. If this callback is not defined, the command will simply ignore the failure and refuse to execute with no sign of failure. The fail gives 2 parameters, a context to the message that activated the command, and an array of results (both failed and passing). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class NsfwCommand extends Command < BaseConfig > { constructor () { super ( 'nsfw' , { aliases : [ 'lewd' , 'pics' ], groups : [ 'user' ], guards : [ isNsfw ], fail : ( r , c ) => { const res = r . filter ( gr => gr . passed === false ); c . msg . channel . send ( `Guards failed with messages: \\`\\`\\` ${ res . map ( gr => gr . message ) . join ( '\\n' ) } \\`\\`\\`` ); }, }); } callback ( ctx : CommandContext < BaseConfig > ) : void { // normal command stuff here } }","title":"Commands"},{"location":"commands/#commands","text":"Blueprint uses a Command class to manage the implementation of commands, for things such as the command's meta, a super() call with the meta of the command, such as the name, groups, aliases, and guards must be used. An example of creating a command can be seen below in the Creating Commands section. Note that this is a breaking change from the old pre-2.4.0 decorator method.","title":"Commands"},{"location":"commands/#guards","text":"Guards a way to add pre-checks to commands. They are simply functions that take the message context and a reference to the blueprint instance and return a GuardResult type. In order for a command using guards to execute, all guards must pass . 1 2 3 4 5 6 7 import { Guard , BaseConfig } from 'blueprint-framework' ; import { TextChannel } from 'discord.js-light' ; const isNsfw : Guard < BaseConfig > = ctx => { if (( ctx . channel as TextChannel ). nsfw ) return { passed : true }; else return { passed : false , message : \"The channel is not marked as NSFW\" }; };","title":"Guards"},{"location":"commands/#creating-commands","text":"Commands are classes extending the abstract Command class, to set up a command you need to use the super() method to assign the command's meta information, then implement the abstract callback method with the functionality of the command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export class PingCommand extends Command { constructor () { super ( 'ping' , { aliases : [ 'latency' , 'lag' ], groups : [ 'user' ], guards : [], }); } async callback ( ctx : CommandContext < BaseConfig > ) { const startTime = Date . now (); const msg = await ctx . message . channel . send ( 'loading...' ); msg . edit ( 'The current ping is `' + ( Date . now () - startTime ) + 'ms`' ); } }","title":"Creating Commands"},{"location":"commands/#handling-guard-failures","text":"When any guard in a command returns false from it's passed property in a result, an optional fail callback is called that can be defined on the meta of a command within the super call. If this callback is not defined, the command will simply ignore the failure and refuse to execute with no sign of failure. The fail gives 2 parameters, a context to the message that activated the command, and an array of results (both failed and passing). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class NsfwCommand extends Command < BaseConfig > { constructor () { super ( 'nsfw' , { aliases : [ 'lewd' , 'pics' ], groups : [ 'user' ], guards : [ isNsfw ], fail : ( r , c ) => { const res = r . filter ( gr => gr . passed === false ); c . msg . channel . send ( `Guards failed with messages: \\`\\`\\` ${ res . map ( gr => gr . message ) . join ( '\\n' ) } \\`\\`\\`` ); }, }); } callback ( ctx : CommandContext < BaseConfig > ) : void { // normal command stuff here } }","title":"Handling Guard Failures"},{"location":"extensions/","text":"Extensions # Extensions are a way for developers to share 'injectable' snippets of code to extend the functionality of the Blueprint library, without the functionality having to be implemented into the library itself. Extensions consist of a function that takes 3 arguments, core which is access to the instance's internals, registry which gives access to the normal registries users have access to, and data which grants writable access to the data registry , these functions can be async or synchronous, but always return void . Creating Extensions # To create an extension it is fairly simple, you want to import the Extension type from Blueprint, and then use it as the type for a function, the function can be an arrow (bound) function, or a function with a this context. 1 2 3 4 5 6 7 8 9 import { Extension } from 'blueprint-framework' ; const extension : Extension = ( core , registry , data ) => { registry . events . register ( 'ready' , ({ core : { logger }}) => { logger ? . getLogger ( 'Extension' ). debug ( 'Successfully Injected!' ); }); }; export default extension ; Using Extensions # To use an extension, it simply needs to be injected using a instance's inject method. This method executes the code inside the extension's function or callback, and essentially does as it is named, \"injects\" the code into the Blueprint instance. Warning Extensions can be dangerous due to how they work, extensions can erase existing events and other things without your knowledge, and could even stealthily inject malicious code without knowledge. 1 2 3 import { ExampleExtension } from 'example-ext' ; bot . inject ( ExampleExtension ); Passing Data To Users # In order to provide a one-way method of providing data or functions to the user of the extension, the data registry is used. While immutable from a user standpoint, the registry can be mutated from extensions, as stated in the page as well, values are also immutable, in order to be changed they need to be re-registered . 1 2 3 4 const extension : Extension = ( core , registry , data ) => { // example passing a 'something' key to users. data . register ( 'something' , 12 ); };","title":"Extensions"},{"location":"extensions/#extensions","text":"Extensions are a way for developers to share 'injectable' snippets of code to extend the functionality of the Blueprint library, without the functionality having to be implemented into the library itself. Extensions consist of a function that takes 3 arguments, core which is access to the instance's internals, registry which gives access to the normal registries users have access to, and data which grants writable access to the data registry , these functions can be async or synchronous, but always return void .","title":"Extensions"},{"location":"extensions/#creating-extensions","text":"To create an extension it is fairly simple, you want to import the Extension type from Blueprint, and then use it as the type for a function, the function can be an arrow (bound) function, or a function with a this context. 1 2 3 4 5 6 7 8 9 import { Extension } from 'blueprint-framework' ; const extension : Extension = ( core , registry , data ) => { registry . events . register ( 'ready' , ({ core : { logger }}) => { logger ? . getLogger ( 'Extension' ). debug ( 'Successfully Injected!' ); }); }; export default extension ;","title":"Creating Extensions"},{"location":"extensions/#using-extensions","text":"To use an extension, it simply needs to be injected using a instance's inject method. This method executes the code inside the extension's function or callback, and essentially does as it is named, \"injects\" the code into the Blueprint instance. Warning Extensions can be dangerous due to how they work, extensions can erase existing events and other things without your knowledge, and could even stealthily inject malicious code without knowledge. 1 2 3 import { ExampleExtension } from 'example-ext' ; bot . inject ( ExampleExtension );","title":"Using Extensions"},{"location":"extensions/#passing-data-to-users","text":"In order to provide a one-way method of providing data or functions to the user of the extension, the data registry is used. While immutable from a user standpoint, the registry can be mutated from extensions, as stated in the page as well, values are also immutable, in order to be changed they need to be re-registered . 1 2 3 4 const extension : Extension = ( core , registry , data ) => { // example passing a 'something' key to users. data . register ( 'something' , 12 ); };","title":"Passing Data To Users"},{"location":"hooks/","text":"Hooks # Hooks are a way to get debugging information from registries inside of Blueprint. All registries extend a Hookable class which implements the hook implementation which adds a hook and unhook method. While you can manually use this to bind hooks, it is recommended to use the Hook class to manage hooks. Binding Hooks # The act of 'binding' a hook binds a callback to a registry to get debug information this is done via the Hook class, in an instance, an example of how to create and bind hooks can be seen below, note that hooking a lot of things can and will spam your console with messages and data if you log everything. 1 2 3 4 5 6 7 import { Blueprint , Hook } from 'blueprint-framework' ; const bot = new Blueprint ( 'config.json' ); const hook = new Hook (( res ) => console . log ( res . message )); hook . bind ( bot . registry . events , bot . registry . groups ); bot . start (); Unbinding Hooks # Unbinding hooks is the act of removing the callback or \"hook\" from registries, the hook class makes this easy by allowing you to use the .unbind() method which takes a list of the hooks you want to unbind. 1 hook . unbind ( bot . registry . events , ...);","title":"Hooks"},{"location":"hooks/#hooks","text":"Hooks are a way to get debugging information from registries inside of Blueprint. All registries extend a Hookable class which implements the hook implementation which adds a hook and unhook method. While you can manually use this to bind hooks, it is recommended to use the Hook class to manage hooks.","title":"Hooks"},{"location":"hooks/#binding-hooks","text":"The act of 'binding' a hook binds a callback to a registry to get debug information this is done via the Hook class, in an instance, an example of how to create and bind hooks can be seen below, note that hooking a lot of things can and will spam your console with messages and data if you log everything. 1 2 3 4 5 6 7 import { Blueprint , Hook } from 'blueprint-framework' ; const bot = new Blueprint ( 'config.json' ); const hook = new Hook (( res ) => console . log ( res . message )); hook . bind ( bot . registry . events , bot . registry . groups ); bot . start ();","title":"Binding Hooks"},{"location":"hooks/#unbinding-hooks","text":"Unbinding hooks is the act of removing the callback or \"hook\" from registries, the hook class makes this easy by allowing you to use the .unbind() method which takes a list of the hooks you want to unbind. 1 hook . unbind ( bot . registry . events , ...);","title":"Unbinding Hooks"},{"location":"permissions/","text":"Permissions # This page will go into detail about what each permission string is for, note that you don't necessarily need to know what each string is, as the Group interface already contains the PermissionString type which gives you the intellisense needed if you use an IDE such as Visual Studio Code, or WebStorm. List Of Permssions # Below you can see a table of all the permission strings that you are given access to when creating groups, note that in future updates more could be added, removed, or changed. key description invite.create user can create instant invites to the guild members.kick user can kick members from the guild members.ban user can ban members from the guild guild.administrator user has administrator permissions on the guild channels.manage user can manage the the guild reactions.add user can add reactions to messages auditlogs.view user can view the audit logs of the guild voice.priority user has voice priority permissions voice.stream user can use video streaming in the guild messages.read user can read messages in the guild messages.send user can send messages in the guild messages.send.tts user can send tts messages in the guild messages.manage user can manage or delete messages in the guild messages.links user can embed links in messages in the guild messages.files user can upload files in the guild messages.read.history user can read message history in the guild messages.mention user can mention everyone or roles in the guild emojis.external user can use external emojis in the guild guild.insights user has access to the current guild's insights voice.connect user can connect to voice channels in the guild voice.speak user can speak in voice channels in the guild voice.manage.mute user can mute members inside of voice channels voice.manage.deafen user can deafen members inside of voice channels voice.manage.move user can move members in voice channels voice.vad user can use voice activity in voice channels nicks.change user can change their own nickname nicks.manage user can manage other people's nicknames roles.manage user can manage roles in the guild webhooks.manage user can manage webhooks in the guild emojis.manage user can manage emojis in the guild guild.manage user can manage the guild","title":"Permissions"},{"location":"permissions/#permissions","text":"This page will go into detail about what each permission string is for, note that you don't necessarily need to know what each string is, as the Group interface already contains the PermissionString type which gives you the intellisense needed if you use an IDE such as Visual Studio Code, or WebStorm.","title":"Permissions"},{"location":"permissions/#list-of-permssions","text":"Below you can see a table of all the permission strings that you are given access to when creating groups, note that in future updates more could be added, removed, or changed. key description invite.create user can create instant invites to the guild members.kick user can kick members from the guild members.ban user can ban members from the guild guild.administrator user has administrator permissions on the guild channels.manage user can manage the the guild reactions.add user can add reactions to messages auditlogs.view user can view the audit logs of the guild voice.priority user has voice priority permissions voice.stream user can use video streaming in the guild messages.read user can read messages in the guild messages.send user can send messages in the guild messages.send.tts user can send tts messages in the guild messages.manage user can manage or delete messages in the guild messages.links user can embed links in messages in the guild messages.files user can upload files in the guild messages.read.history user can read message history in the guild messages.mention user can mention everyone or roles in the guild emojis.external user can use external emojis in the guild guild.insights user has access to the current guild's insights voice.connect user can connect to voice channels in the guild voice.speak user can speak in voice channels in the guild voice.manage.mute user can mute members inside of voice channels voice.manage.deafen user can deafen members inside of voice channels voice.manage.move user can move members in voice channels voice.vad user can use voice activity in voice channels nicks.change user can change their own nickname nicks.manage user can manage other people's nicknames roles.manage user can manage roles in the guild webhooks.manage user can manage webhooks in the guild emojis.manage user can manage emojis in the guild guild.manage user can manage the guild","title":"List Of Permssions"},{"location":"plugins/","text":"Plugins # Blueprint uses a plugin system to group commands together, this also allows the ability to allow multiple commands to share the same group(s) without having to manually specify the groups on every single command. Plugins act simply as groups and can apply permissions to multiple commands by passing the permission groups to the plugin. Creating Plugins # Creating a plugin is extremely simple, you just need to create a new instance of the Plugin class, pasing the metadata such as the name of the plugin and optionally the groups you want the commands inside of it to inherit. As of version 3.0.0, commands are now passed into the constructor of plugins inside the meta object. 1 2 3 4 5 6 7 import { Plugin } from 'blueprint-framework' ; const adminPlugin = new Plugin ({ groups : [ 'admin' , 'developer' ], commands : [ new EvalCommand ()], name : 'admin' , });","title":"Plugins"},{"location":"plugins/#plugins","text":"Blueprint uses a plugin system to group commands together, this also allows the ability to allow multiple commands to share the same group(s) without having to manually specify the groups on every single command. Plugins act simply as groups and can apply permissions to multiple commands by passing the permission groups to the plugin.","title":"Plugins"},{"location":"plugins/#creating-plugins","text":"Creating a plugin is extremely simple, you just need to create a new instance of the Plugin class, pasing the metadata such as the name of the plugin and optionally the groups you want the commands inside of it to inherit. As of version 3.0.0, commands are now passed into the constructor of plugins inside the meta object. 1 2 3 4 5 6 7 import { Plugin } from 'blueprint-framework' ; const adminPlugin = new Plugin ({ groups : [ 'admin' , 'developer' ], commands : [ new EvalCommand ()], name : 'admin' , });","title":"Creating Plugins"},{"location":"config/discord/","text":"Bot Configuration # Blueprint is based on the discord.js-light Discord library. This allows it to be extremely light-weight and performant, while also providing a solid foundation. There is 2 sections that are required in order for a basic Blueprint-based bot to start at the minimum. These are the bot and developers sections, these two sections portain to Discord specific information such as the bot token, and developer user IDs. Bot Settings # The bot configuration section defines information about the bot, such as the bot's prefix, token, and options. It contains 2 required keys ( prefix , and token ) and 1 optional key ( options ). The options key is an object containing the discord.js-light client options (you can also combine the regular discord.js client options with these too), while as the prefix and token keys are strings containing the bot's prefix, and the bot's token obtained from the developer portal . 1 2 3 4 5 6 7 8 9 10 { \"bot\" : { \"prefix\" : \"!\" , \"token\" : \"example_token\" , \"options\" : { \"cacheGuilds\" : true , \"cacheChannels\" : false } } } Developer List # The developers configuration section defines an array or list containing Discord user IDs as strings. This section is required as it used internally to create a immutable developer permission group to allow users to create developer-specific commands, among other functionality. 1 2 3 4 5 { \"developers\" : [ \"333459879379337216\" ] }","title":"Discord"},{"location":"config/discord/#bot-configuration","text":"Blueprint is based on the discord.js-light Discord library. This allows it to be extremely light-weight and performant, while also providing a solid foundation. There is 2 sections that are required in order for a basic Blueprint-based bot to start at the minimum. These are the bot and developers sections, these two sections portain to Discord specific information such as the bot token, and developer user IDs.","title":"Bot Configuration"},{"location":"config/discord/#bot-settings","text":"The bot configuration section defines information about the bot, such as the bot's prefix, token, and options. It contains 2 required keys ( prefix , and token ) and 1 optional key ( options ). The options key is an object containing the discord.js-light client options (you can also combine the regular discord.js client options with these too), while as the prefix and token keys are strings containing the bot's prefix, and the bot's token obtained from the developer portal . 1 2 3 4 5 6 7 8 9 10 { \"bot\" : { \"prefix\" : \"!\" , \"token\" : \"example_token\" , \"options\" : { \"cacheGuilds\" : true , \"cacheChannels\" : false } } }","title":"Bot Settings"},{"location":"config/discord/#developer-list","text":"The developers configuration section defines an array or list containing Discord user IDs as strings. This section is required as it used internally to create a immutable developer permission group to allow users to create developer-specific commands, among other functionality. 1 2 3 4 5 { \"developers\" : [ \"333459879379337216\" ] }","title":"Developer List"},{"location":"config/extensions/","text":"Config Extensions # Blueprint has a extension system, on top of this allowing extension developers to extend the base Blueprint configuration interface, allowing extension-specific configuration options. This is done by creating a custom config interface that extends the BaseConfig interface, which is then passed to everything that requires a generic type, which is used to tell the framework what configuration to use, by default if no configuration type is used, it assumes you want to use the BaseConfig . Creating Custom Configs # Creating a custom configuration scheme is fairly simple, as you only need to import and extend the BaseConfig interface, and then use that from then onwards, an example of how to do this is below. 1 2 3 4 5 6 7 8 import { BaseConfig } from 'blueprint-framework' ; // Sentry.io example extension config export interface SentryConfig extends BaseConfig { sentry : { dsn : string ; } } Third Party Config Types # When using an extension that uses a custom config interface, it can often get confusing, especially when multiple extensions have custom configuration formats, this is easily fixed by extending the extension configs to combine them into a single type. 1 2 3 interface FullConfig extends BaseConfig , SentryConfig , OtherExtensionConfig {} const bot = new Blueprint < FullConfig > ( 'config.json' );","title":"Extending"},{"location":"config/extensions/#config-extensions","text":"Blueprint has a extension system, on top of this allowing extension developers to extend the base Blueprint configuration interface, allowing extension-specific configuration options. This is done by creating a custom config interface that extends the BaseConfig interface, which is then passed to everything that requires a generic type, which is used to tell the framework what configuration to use, by default if no configuration type is used, it assumes you want to use the BaseConfig .","title":"Config Extensions"},{"location":"config/extensions/#creating-custom-configs","text":"Creating a custom configuration scheme is fairly simple, as you only need to import and extend the BaseConfig interface, and then use that from then onwards, an example of how to do this is below. 1 2 3 4 5 6 7 8 import { BaseConfig } from 'blueprint-framework' ; // Sentry.io example extension config export interface SentryConfig extends BaseConfig { sentry : { dsn : string ; } }","title":"Creating Custom Configs"},{"location":"config/extensions/#third-party-config-types","text":"When using an extension that uses a custom config interface, it can often get confusing, especially when multiple extensions have custom configuration formats, this is easily fixed by extending the extension configs to combine them into a single type. 1 2 3 interface FullConfig extends BaseConfig , SentryConfig , OtherExtensionConfig {} const bot = new Blueprint < FullConfig > ( 'config.json' );","title":"Third Party Config Types"},{"location":"config/logging/","text":"Logging Configuration # While Blueprint doesn't necessarily force a specific logger, when the logging section is present in your configuration file, it uses the log4js library due to it's powerful configuration and flexibility. This section unlike the 2 sections detailed in the Discord page, is optional and when not specified disables the use of log4js completely, this allows the use of other loggers via Blueprint's extension system. Appenders # Appenders are the way log4js outputs messages to the type of log you want to use, there is many many types of appenders, especially third party ones, but the most common appender type is the stdout appender, which simply outputs log messages to your console or TTY. It requires no options other than setting the type key to stdout , while as other types may require additional configuration. 1 2 3 4 5 6 7 8 9 { \"logging\" : { \"appenders\" : { \"default\" : { \"type\" : \"stdout\" } } } } Categories # Categories are a way to group log events, as talked about on this page . They can use multiple appenders, and can allow you to seperate different log levels into different outputs, which is one primary reason why Blueprint uses log4js by default. By default log4js looks for a category named default , and uses the settings from that. 1 2 3 4 5 6 7 8 9 10 { \"logging\" : { \"categories\" : { \"default\" : { \"appenders\" : [ \"default\" ], \"level\" : \"debug\" } } } }","title":"Logging"},{"location":"config/logging/#logging-configuration","text":"While Blueprint doesn't necessarily force a specific logger, when the logging section is present in your configuration file, it uses the log4js library due to it's powerful configuration and flexibility. This section unlike the 2 sections detailed in the Discord page, is optional and when not specified disables the use of log4js completely, this allows the use of other loggers via Blueprint's extension system.","title":"Logging Configuration"},{"location":"config/logging/#appenders","text":"Appenders are the way log4js outputs messages to the type of log you want to use, there is many many types of appenders, especially third party ones, but the most common appender type is the stdout appender, which simply outputs log messages to your console or TTY. It requires no options other than setting the type key to stdout , while as other types may require additional configuration. 1 2 3 4 5 6 7 8 9 { \"logging\" : { \"appenders\" : { \"default\" : { \"type\" : \"stdout\" } } } }","title":"Appenders"},{"location":"config/logging/#categories","text":"Categories are a way to group log events, as talked about on this page . They can use multiple appenders, and can allow you to seperate different log levels into different outputs, which is one primary reason why Blueprint uses log4js by default. By default log4js looks for a category named default , and uses the settings from that. 1 2 3 4 5 6 7 8 9 10 { \"logging\" : { \"categories\" : { \"default\" : { \"appenders\" : [ \"default\" ], \"level\" : \"debug\" } } } }","title":"Categories"},{"location":"config/parsers/","text":"Configuration Parsers # Blueprint allows the ability to use whatever configuration format the user wants, this includes JSON, YAML, TOML, INI, etc natively, this is done by providing a parser and encoding to the Blueprint constuctor. It should however be noted that the configuration object parsed and returned must return the same types as the default JSON parser used when no parser is provided. 1 2 3 4 5 import { parse as parser } from 'yaml' ; const bot = new Blueprint ( 'config.yml' , { config : { parser , encoding : 'utf-8' }, }); Important Notes # While you can technically use any format your heart desires, we will only provide support towards popular or well known formats, such as JSON, YAML, or TOML, and some others. If you for whatever reason decide to use something obscure such as S-Expressions, or something else strange in the \"config world\", then no support will be provided, and you will have to figure out why something isn't working on your own.","title":"Parsers"},{"location":"config/parsers/#configuration-parsers","text":"Blueprint allows the ability to use whatever configuration format the user wants, this includes JSON, YAML, TOML, INI, etc natively, this is done by providing a parser and encoding to the Blueprint constuctor. It should however be noted that the configuration object parsed and returned must return the same types as the default JSON parser used when no parser is provided. 1 2 3 4 5 import { parse as parser } from 'yaml' ; const bot = new Blueprint ( 'config.yml' , { config : { parser , encoding : 'utf-8' }, });","title":"Configuration Parsers"},{"location":"config/parsers/#important-notes","text":"While you can technically use any format your heart desires, we will only provide support towards popular or well known formats, such as JSON, YAML, or TOML, and some others. If you for whatever reason decide to use something obscure such as S-Expressions, or something else strange in the \"config world\", then no support will be provided, and you will have to figure out why something isn't working on your own.","title":"Important Notes"},{"location":"config/prefixes/","text":"Custom Prefixes # By default Blueprint only allows the use of a single prefix, defined in the bot section, read more about this in the Discord section. However, as of v3, you can now setup a function to hot-load custom prefixes which are cached after the first load to prevent heavy database load every single command call. Enabling Custom Prefixes # To enable custom prefixes you need to enable the prefix section of the Blueprint instance options. This section contains 2 properties: enabled and load , enabled is a boolean which enables or disables the use of custom prefixes, load is a callback used to actually fetch the custom prefix for the guild. The load function only needs to be defined if you have the enabled property set to true in the options. 1 2 3 4 5 6 7 8 9 const bot = new Blueprint ( 'config.yml' , { prefix : { enabled : true , load : ( ctx ) => { // ctx contains the message and blueprint reference // do what you need to here to get the prefix and return a string }, } });","title":"Prefixes"},{"location":"config/prefixes/#custom-prefixes","text":"By default Blueprint only allows the use of a single prefix, defined in the bot section, read more about this in the Discord section. However, as of v3, you can now setup a function to hot-load custom prefixes which are cached after the first load to prevent heavy database load every single command call.","title":"Custom Prefixes"},{"location":"config/prefixes/#enabling-custom-prefixes","text":"To enable custom prefixes you need to enable the prefix section of the Blueprint instance options. This section contains 2 properties: enabled and load , enabled is a boolean which enables or disables the use of custom prefixes, load is a callback used to actually fetch the custom prefix for the guild. The load function only needs to be defined if you have the enabled property set to true in the options. 1 2 3 4 5 6 7 8 9 const bot = new Blueprint ( 'config.yml' , { prefix : { enabled : true , load : ( ctx ) => { // ctx contains the message and blueprint reference // do what you need to here to get the prefix and return a string }, } });","title":"Enabling Custom Prefixes"},{"location":"registry/data/","text":"Data Registry # The data registry is a semi-immutable registry in a Blueprint instance used for extensions to share data or functionality to the user. From a instance or the registry property, you are unable to actually modify or mutate the registry. This registry is also unique in the sense that already-existing keys can not be changed, this is to prevent extensions from mutating other extensions data values. Obtaining Data # Unlike most registries, you are only able to obtain data from the registry from a user standpoint. To do this it is a simple call to the Blueprint.registry.data.get() method, which takes a key to the data entry you want to obtain, this key is set by extensions and are not logged or detailed anywhere, so the extension authors must explain this on their end. 1 2 3 4 5 6 7 8 import { Logger , LogExtension } from 'log-extension' ; let logger : Logger ; bot . inject ( LogExtension ); bot . registry . events . register ( 'ready' , ({ registry : { data }}) => { logger = data . get ( 'logger' ) as Logger ; });","title":"Data"},{"location":"registry/data/#data-registry","text":"The data registry is a semi-immutable registry in a Blueprint instance used for extensions to share data or functionality to the user. From a instance or the registry property, you are unable to actually modify or mutate the registry. This registry is also unique in the sense that already-existing keys can not be changed, this is to prevent extensions from mutating other extensions data values.","title":"Data Registry"},{"location":"registry/data/#obtaining-data","text":"Unlike most registries, you are only able to obtain data from the registry from a user standpoint. To do this it is a simple call to the Blueprint.registry.data.get() method, which takes a key to the data entry you want to obtain, this key is set by extensions and are not logged or detailed anywhere, so the extension authors must explain this on their end. 1 2 3 4 5 6 7 8 import { Logger , LogExtension } from 'log-extension' ; let logger : Logger ; bot . inject ( LogExtension ); bot . registry . events . register ( 'ready' , ({ registry : { data }}) => { logger = data . get ( 'logger' ) as Logger ; });","title":"Obtaining Data"},{"location":"registry/events/","text":"Event Registry # To manage client events, such as when the bot is ready, or a message is received, Blueprint uses a event-specific registry allowing a modular yet familiar syntax to create event listeners when necessary. Note that while you could in theory do all the command handling yourself, the event registry automatically handles command execution and permission checking. Creating events # To create or register an event you use the registry's register() method which takes 2 arguments, the name of the event as a string, as well as a callback to run when the event is triggered. This is very similar to eris' client.on method, and even extends the types used. 1 2 3 bot . registry . events . register ( 'ready' , ({ core : { logger }}) => { logger ? . getLogger ( 'Client' ). info ( 'Connected to Discord' ); }); To unregister an event, it follows the same premise as other registries and uses the unregister() method which takes the name of the event to remove. 1 bot . registry . events . unregister ( 'ready' ); External event callbacks # Due to how the event registry is setup, if you want to use a named function and other methods as a callback and pass that, it needs to follow the type ClientEvents<T> , where T in this case is the return type of the callback, in most cases the return type used will simply be void as no return type is needed. While this is completely possible and allowed, there will be no support provided with this method due to the complexity of getting it to work properly.","title":"Events"},{"location":"registry/events/#event-registry","text":"To manage client events, such as when the bot is ready, or a message is received, Blueprint uses a event-specific registry allowing a modular yet familiar syntax to create event listeners when necessary. Note that while you could in theory do all the command handling yourself, the event registry automatically handles command execution and permission checking.","title":"Event Registry"},{"location":"registry/events/#creating-events","text":"To create or register an event you use the registry's register() method which takes 2 arguments, the name of the event as a string, as well as a callback to run when the event is triggered. This is very similar to eris' client.on method, and even extends the types used. 1 2 3 bot . registry . events . register ( 'ready' , ({ core : { logger }}) => { logger ? . getLogger ( 'Client' ). info ( 'Connected to Discord' ); }); To unregister an event, it follows the same premise as other registries and uses the unregister() method which takes the name of the event to remove. 1 bot . registry . events . unregister ( 'ready' );","title":"Creating events"},{"location":"registry/events/#external-event-callbacks","text":"Due to how the event registry is setup, if you want to use a named function and other methods as a callback and pass that, it needs to follow the type ClientEvents<T> , where T in this case is the return type of the callback, in most cases the return type used will simply be void as no return type is needed. While this is completely possible and allowed, there will be no support provided with this method due to the complexity of getting it to work properly.","title":"External event callbacks"},{"location":"registry/groups/","text":"Group Registry # For permissions Blueprint uses a permission group system, grouping users by what Discord permissions each user has access to, then judging if they can run commands or not by what groups they are in. This allows users to have a fairly flexible, yet simplistic and modular permission system, these groups are made of 3 things: inheritance, permissions, and overrides, as well as a unique identifier. Creating groups # To create a group you use Blueprint's group registry, which manages all the groups and their properties, as well as checks what groups users are in. This is heavily inspired by Minecraft permission system plugins such as PermissionsEx, and LuckPerms, and uses dot notation strings (for example, messages.read ) to define permssions in a declarative manner. 1 2 3 bot . registry . groups . register ( 'groupName' , { /** Group definition here **/ }); You can also undefine or remove groups by using the .unregister() method likewise 1 bot . registry . groups . unregister ( 'groupName' ); Inheritance # Blueprint allows groups to inherit the permissions and overrides of other groups, creating so-called \"compound groups\" in the process. This is all done at the registration stage of the bot and therefor groups are afterwords immutable unless they are reregistered. To inherit a group, you just need to add a group's name to the inherits array in the group definition. 1 2 3 bot . registry . groups . register ( 'groupName' , { inherits : [ 'otherGroup' ], }); Permissions # For permissions, Blueprint uses a string system somewhat similar to how Minecraft plugins manage permissions, with dot-notation based strings, an example of this as said before is something similar to messages.read , or messages.read.history , among others. A list of permissions and their explanations can be read on the permissions page for more information. The permissions section of group definitions is required as they are needed to define what groups users are in. 1 2 3 4 5 6 7 8 bot . registry . groups . register ( 'groupName' , { permissions : [ 'messages.read' , 'messages.read.history' , 'messages.send' , 'nicks.change' , ], }); Overrides # Overrides allow users to force specific users or roles into a specific permission group. There are typically two types of overrides, user overrides and role overrides. Each one is a simple object containing a type field and an id field with the id of the role or user. 1 2 3 4 5 bot . registry . groups . register ( 'groupName' , { overrides : [ { type : 'user' , id : '333459879379337216' }, ] });","title":"Groups"},{"location":"registry/groups/#group-registry","text":"For permissions Blueprint uses a permission group system, grouping users by what Discord permissions each user has access to, then judging if they can run commands or not by what groups they are in. This allows users to have a fairly flexible, yet simplistic and modular permission system, these groups are made of 3 things: inheritance, permissions, and overrides, as well as a unique identifier.","title":"Group Registry"},{"location":"registry/groups/#creating-groups","text":"To create a group you use Blueprint's group registry, which manages all the groups and their properties, as well as checks what groups users are in. This is heavily inspired by Minecraft permission system plugins such as PermissionsEx, and LuckPerms, and uses dot notation strings (for example, messages.read ) to define permssions in a declarative manner. 1 2 3 bot . registry . groups . register ( 'groupName' , { /** Group definition here **/ }); You can also undefine or remove groups by using the .unregister() method likewise 1 bot . registry . groups . unregister ( 'groupName' );","title":"Creating groups"},{"location":"registry/groups/#inheritance","text":"Blueprint allows groups to inherit the permissions and overrides of other groups, creating so-called \"compound groups\" in the process. This is all done at the registration stage of the bot and therefor groups are afterwords immutable unless they are reregistered. To inherit a group, you just need to add a group's name to the inherits array in the group definition. 1 2 3 bot . registry . groups . register ( 'groupName' , { inherits : [ 'otherGroup' ], });","title":"Inheritance"},{"location":"registry/groups/#permissions","text":"For permissions, Blueprint uses a string system somewhat similar to how Minecraft plugins manage permissions, with dot-notation based strings, an example of this as said before is something similar to messages.read , or messages.read.history , among others. A list of permissions and their explanations can be read on the permissions page for more information. The permissions section of group definitions is required as they are needed to define what groups users are in. 1 2 3 4 5 6 7 8 bot . registry . groups . register ( 'groupName' , { permissions : [ 'messages.read' , 'messages.read.history' , 'messages.send' , 'nicks.change' , ], });","title":"Permissions"},{"location":"registry/groups/#overrides","text":"Overrides allow users to force specific users or roles into a specific permission group. There are typically two types of overrides, user overrides and role overrides. Each one is a simple object containing a type field and an id field with the id of the role or user. 1 2 3 4 5 bot . registry . groups . register ( 'groupName' , { overrides : [ { type : 'user' , id : '333459879379337216' }, ] });","title":"Overrides"},{"location":"registry/plugins/","text":"Plugin Registry # Blueprint uses a registry to manage plugins similar to groups, and events. It is faily simple to register plugins, as you only need to pass the plugin instance itself, and everything else will be handled internally. Similar to other registries, the plugin registry can also be hooked. Creating Plugins # For more information on plugins and how to create them read the plugins page. Plugins are fairly simple to use, but due to them not being a registry in a sense, they don't fall under the registries section, so it's best to read the page about them. Registering Plugins # Unlike the other registries, the plugin registry only takes a single value whern registering them, which is the instance of the Plugin class itself. Everything else is handled internally by accessing the plugin's meta property which is set when creating a new plugin instance. 1 bot . registry . plugins . register ( adminPlugin ); Like other registries, you can unregister plugins by using the unregister() method with the name of the plugin. 1 bot . registry . plugins . unregister ( 'admin' );","title":"Plugins"},{"location":"registry/plugins/#plugin-registry","text":"Blueprint uses a registry to manage plugins similar to groups, and events. It is faily simple to register plugins, as you only need to pass the plugin instance itself, and everything else will be handled internally. Similar to other registries, the plugin registry can also be hooked.","title":"Plugin Registry"},{"location":"registry/plugins/#creating-plugins","text":"For more information on plugins and how to create them read the plugins page. Plugins are fairly simple to use, but due to them not being a registry in a sense, they don't fall under the registries section, so it's best to read the page about them.","title":"Creating Plugins"},{"location":"registry/plugins/#registering-plugins","text":"Unlike the other registries, the plugin registry only takes a single value whern registering them, which is the instance of the Plugin class itself. Everything else is handled internally by accessing the plugin's meta property which is set when creating a new plugin instance. 1 bot . registry . plugins . register ( adminPlugin ); Like other registries, you can unregister plugins by using the unregister() method with the name of the plugin. 1 bot . registry . plugins . unregister ( 'admin' );","title":"Registering Plugins"}]}